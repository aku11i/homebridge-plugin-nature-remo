/* tslint:disable */
/* eslint-disable */
/**
 * Nature API
 * Read/Write Nature Remo
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Specify \"power-off\" always if you want the air conditioner powered off. Empty means powered on.
 * @export
 * @enum {string}
 */

export enum ACButton {
    Empty = '',
    PowerOff = 'power-off'
}

/**
 * 
 * @export
 * @interface AirCon
 */
export interface AirCon {
    /**
     * 
     * @type {AirConRange}
     * @memberof AirCon
     */
    range?: AirConRange;
    /**
     * 
     * @type {string}
     * @memberof AirCon
     */
    tempUnit?: AirConTempUnitEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AirConTempUnitEnum {
    Empty = '',
    C = 'c',
    F = 'f'
}

/**
 * 
 * @export
 * @interface AirConParams
 */
export interface AirConParams {
    /**
     * The temperature in string format. The unit is described in Aircon object. The range of Temperatures which the air conditioner accepts depends on the air conditioner model and operation mode. Check the \'AirConRangeMode\' information in the response for the range of the particular air conditioner model and operation mode.
     * @type {string}
     * @memberof AirConParams
     */
    temp?: string;
    /**
     * 
     * @type {OperationMode}
     * @memberof AirConParams
     */
    mode?: OperationMode;
    /**
     * 
     * @type {AirVolume}
     * @memberof AirConParams
     */
    vol?: AirVolume;
    /**
     * 
     * @type {AirDirection}
     * @memberof AirConParams
     */
    dir?: AirDirection;
    /**
     * 
     * @type {ACButton}
     * @memberof AirConParams
     */
    button?: ACButton;
}
/**
 * 
 * @export
 * @interface AirConRange
 */
export interface AirConRange {
    /**
     * 
     * @type {AirConRangeModes}
     * @memberof AirConRange
     */
    modes?: AirConRangeModes;
    /**
     * 
     * @type {Array<ACButton>}
     * @memberof AirConRange
     */
    fixedButtons?: Array<ACButton>;
}
/**
 * 
 * @export
 * @interface AirConRangeMode
 */
export interface AirConRangeMode {
    /**
     * 
     * @type {Array<string>}
     * @memberof AirConRangeMode
     */
    temp?: Array<string>;
    /**
     * 
     * @type {Array<AirVolume>}
     * @memberof AirConRangeMode
     */
    vol?: Array<AirVolume>;
    /**
     * 
     * @type {Array<AirDirection>}
     * @memberof AirConRangeMode
     */
    dir?: Array<AirDirection>;
}
/**
 * 
 * @export
 * @interface AirConRangeModes
 */
export interface AirConRangeModes {
    /**
     * 
     * @type {AirConRangeMode}
     * @memberof AirConRangeModes
     */
    cool?: AirConRangeMode;
    /**
     * 
     * @type {AirConRangeMode}
     * @memberof AirConRangeModes
     */
    warm?: AirConRangeMode;
    /**
     * 
     * @type {AirConRangeMode}
     * @memberof AirConRangeModes
     */
    dry?: AirConRangeMode;
    /**
     * 
     * @type {AirConRangeMode}
     * @memberof AirConRangeModes
     */
    blow?: AirConRangeMode;
    /**
     * 
     * @type {AirConRangeMode}
     * @memberof AirConRangeModes
     */
    auto?: AirConRangeMode;
}
/**
 * Empty means automatic.
 * @export
 * @enum {string}
 */

export enum AirDirection {
    Empty = ''
}

/**
 * Empty means automatic. Numbers express the amount of volume. The range of AirVolumes which the air conditioner accepts depends on the air conditioner model and operation mode. Check the \'AirConRangeMode\' information in the response for the range of the particular air conditioner model and operation mode.
 * @export
 * @enum {string}
 */

export enum AirVolume {
    Empty = '',
    Auto = 'auto',
    _1 = '1',
    _2 = '2',
    _3 = '3',
    _4 = '4',
    _5 = '5',
    _6 = '6',
    _7 = '7',
    _8 = '8',
    _9 = '9',
    _10 = '10'
}

/**
 * 
 * @export
 * @interface Appliance
 */
export interface Appliance {
    /**
     * 
     * @type {string}
     * @memberof Appliance
     */
    id?: string;
    /**
     * 
     * @type {DeviceCore}
     * @memberof Appliance
     */
    device?: DeviceCore;
    /**
     * 
     * @type {ApplianceModel}
     * @memberof Appliance
     */
    model?: ApplianceModel;
    /**
     * 
     * @type {string}
     * @memberof Appliance
     */
    nickname?: string;
    /**
     * Basename of the image file included in the app. Ex: \"ico_ac_1\" 
     * @type {string}
     * @memberof Appliance
     */
    image?: string;
    /**
     * 
     * @type {ApplianceType}
     * @memberof Appliance
     */
    type?: ApplianceType;
    /**
     * 
     * @type {AirConParams}
     * @memberof Appliance
     */
    settings?: AirConParams;
    /**
     * 
     * @type {AirCon}
     * @memberof Appliance
     */
    aircon?: AirCon;
    /**
     * 
     * @type {Array<Signal>}
     * @memberof Appliance
     */
    signals?: Array<Signal>;
    /**
     * 
     * @type {TV}
     * @memberof Appliance
     */
    tv?: TV;
    /**
     * 
     * @type {LIGHT}
     * @memberof Appliance
     */
    light?: LIGHT;
    /**
     * 
     * @type {SmartMeter}
     * @memberof Appliance
     */
    smart_meter?: SmartMeter;
}
/**
 * 
 * @export
 * @interface ApplianceModel
 */
export interface ApplianceModel {
    /**
     * 
     * @type {string}
     * @memberof ApplianceModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplianceModel
     */
    manufacturer?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplianceModel
     */
    remote_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplianceModel
     */
    name?: string;
    /**
     * Basename of the image file included in the app. Ex: \"ico_ac_1\" 
     * @type {string}
     * @memberof ApplianceModel
     */
    image?: string;
}
/**
 * 
 * @export
 * @interface ApplianceModelAndParam
 */
export interface ApplianceModelAndParam {
    /**
     * 
     * @type {ApplianceModel}
     * @memberof ApplianceModelAndParam
     */
    model?: ApplianceModel;
    /**
     * 
     * @type {AirConParams}
     * @memberof ApplianceModelAndParam
     */
    params?: AirConParams;
}
/**
 * Type of the appliance. \"AC\" (Air conditioner), \"TV\" and \"LIGHT\" are 1st class citizen appliance, which is included in our IRDB (InfraRed signals DataBase). The \"ApplianceModel\" stores meta data about the appliance. We provide AC specific UI. Everything else is \"IR\". We just learn the signals from the remote and store them, and when users tap the button on the smartphone app, our server sends it through Remo.
 * @export
 * @enum {string}
 */

export enum ApplianceType {
    Ac = 'AC',
    Tv = 'TV',
    Light = 'LIGHT',
    Ir = 'IR'
}

/**
 * 
 * @export
 * @interface Button
 */
export interface Button {
    /**
     * Name of button. It is used for \"POST /1/{applaince}/tv\" and \"POST /1/{appliance}/light\".
     * @type {string}
     * @memberof Button
     */
    name?: string;
    /**
     * Basename of the image file included in the app. Ex: \"ico_ac_1\" 
     * @type {string}
     * @memberof Button
     */
    image?: string;
    /**
     * Label of button.
     * @type {string}
     * @memberof Button
     */
    label?: string;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    temperature_offset?: number;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    humidity_offset?: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    firmware_version?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    mac_address?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    serial_number?: string;
    /**
     * 
     * @type {DeviceNewestEvents}
     * @memberof Device
     */
    newest_events?: DeviceNewestEvents;
}
/**
 * 
 * @export
 * @interface DeviceCore
 */
export interface DeviceCore {
    /**
     * 
     * @type {string}
     * @memberof DeviceCore
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceCore
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceCore
     */
    temperature_offset?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceCore
     */
    humidity_offset?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceCore
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceCore
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceCore
     */
    firmware_version?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceCore
     */
    mac_address?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceCore
     */
    serial_number?: string;
}
/**
 * 
 * @export
 * @interface DeviceNewestEvents
 */
export interface DeviceNewestEvents {
    /**
     * 
     * @type {SensorValue}
     * @memberof DeviceNewestEvents
     */
    te?: SensorValue;
    /**
     * 
     * @type {SensorValue}
     * @memberof DeviceNewestEvents
     */
    hu?: SensorValue;
    /**
     * 
     * @type {SensorValue}
     * @memberof DeviceNewestEvents
     */
    il?: SensorValue;
    /**
     * 
     * @type {SensorValue}
     * @memberof DeviceNewestEvents
     */
    mo?: SensorValue;
}
/**
 * The ECHONET lite properties fetched from the appliance. See \"Detailed Requirements for ECHONET Device Objects\" for more details. ref. https://echonet.jp/spec_object_rl_en/ 
 * @export
 * @interface EchonetLiteProperty
 */
export interface EchonetLiteProperty {
    /**
     * 
     * @type {string}
     * @memberof EchonetLiteProperty
     */
    name?: string;
    /**
     * ECHONET Property
     * @type {number}
     * @memberof EchonetLiteProperty
     */
    epc?: number;
    /**
     * 
     * @type {string}
     * @memberof EchonetLiteProperty
     */
    val?: string;
    /**
     * 
     * @type {string}
     * @memberof EchonetLiteProperty
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface LIGHT
 */
export interface LIGHT {
    /**
     * 
     * @type {LIGHTState}
     * @memberof LIGHT
     */
    state?: LIGHTState;
    /**
     * 
     * @type {Array<Button>}
     * @memberof LIGHT
     */
    buttons?: Array<Button>;
}
/**
 * 
 * @export
 * @interface LIGHTState
 */
export interface LIGHTState {
    /**
     * 
     * @type {string}
     * @memberof LIGHTState
     */
    brightness?: string;
    /**
     * 
     * @type {string}
     * @memberof LIGHTState
     */
    power?: LIGHTStatePowerEnum;
    /**
     * 
     * @type {string}
     * @memberof LIGHTState
     */
    last_button?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum LIGHTStatePowerEnum {
    On = 'on',
    Off = 'off'
}

/**
 * The range of OperationModes which the air conditioner accepts depends on the air conditioner model. Check the \'AirConRangeMode\' information in the response for the range of the particular air conditioner model.
 * @export
 * @enum {string}
 */

export enum OperationMode {
    Empty = '',
    Cool = 'cool',
    Warm = 'warm',
    Dry = 'dry',
    Blow = 'blow',
    Auto = 'auto'
}

/**
 * The reference key to SensorValue means \"te\" = temperature, \"hu\" = humidity, \"il\" = illumination, \"mo\" = movement. The val of \"mo\" is always 1 and when movement event is captured created_at is updated. 
 * @export
 * @interface SensorValue
 */
export interface SensorValue {
    /**
     * 
     * @type {number}
     * @memberof SensorValue
     */
    val?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorValue
     */
    created_at?: string;
}
/**
 * 
 * @export
 * @interface Signal
 */
export interface Signal {
    /**
     * 
     * @type {string}
     * @memberof Signal
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Signal
     */
    name?: string;
    /**
     * Basename of the image file included in the app. Ex: \"ico_ac_1\" 
     * @type {string}
     * @memberof Signal
     */
    image?: string;
}
/**
 * 
 * @export
 * @interface SmartMeter
 */
export interface SmartMeter {
    /**
     * 
     * @type {Array<EchonetLiteProperty>}
     * @memberof SmartMeter
     */
    echonetlite_properties?: Array<EchonetLiteProperty>;
}
/**
 * 
 * @export
 * @interface TV
 */
export interface TV {
    /**
     * 
     * @type {TVState}
     * @memberof TV
     */
    state?: TVState;
    /**
     * 
     * @type {Array<Button>}
     * @memberof TV
     */
    buttons?: Array<Button>;
}
/**
 * 
 * @export
 * @interface TVState
 */
export interface TVState {
    /**
     * 
     * @type {string}
     * @memberof TVState
     */
    input?: TVStateInputEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TVStateInputEnum {
    T = 't',
    Bs = 'bs',
    Cs = 'cs'
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    nickname?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Reorder appliances.
         * @param {string} appliances List of all appliances\\\&#39; IDs comma separated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1applianceOrdersPost: async (appliances: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appliances' is not null or undefined
            assertParamExists('_1applianceOrdersPost', 'appliances', appliances)
            const localVarPath = `/1/appliance_orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic"], configuration)


            if (appliances !== undefined) { 
                localVarFormParams.set('appliances', appliances as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update air conditioner settings.
         * @param {string} appliance Appliance ID.
         * @param {string} [temperature] Temperature
         * @param {string} [operationMode] AC operation mode
         * @param {string} [airVolume] AC air volume
         * @param {string} [airDirection] AC air direction
         * @param {string} [button] Button
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesApplianceAirconSettingsPost: async (appliance: string, temperature?: string, operationMode?: string, airVolume?: string, airDirection?: string, button?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appliance' is not null or undefined
            assertParamExists('_1appliancesApplianceAirconSettingsPost', 'appliance', appliance)
            const localVarPath = `/1/appliances/{appliance}/aircon_settings`
                .replace(`{${"appliance"}}`, encodeURIComponent(String(appliance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["sendir"], configuration)


            if (temperature !== undefined) { 
                localVarFormParams.set('temperature', temperature as any);
            }
    
            if (operationMode !== undefined) { 
                localVarFormParams.set('operation_mode', operationMode as any);
            }
    
            if (airVolume !== undefined) { 
                localVarFormParams.set('air_volume', airVolume as any);
            }
    
            if (airDirection !== undefined) { 
                localVarFormParams.set('air_direction', airDirection as any);
            }
    
            if (button !== undefined) { 
                localVarFormParams.set('button', button as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete appliance.
         * @param {string} appliance Appliance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesApplianceDeletePost: async (appliance: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appliance' is not null or undefined
            assertParamExists('_1appliancesApplianceDeletePost', 'appliance', appliance)
            const localVarPath = `/1/appliances/{appliance}/delete`
                .replace(`{${"appliance"}}`, encodeURIComponent(String(appliance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send light infrared signal.
         * @param {string} appliance Appliance ID.
         * @param {string} button Button name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesApplianceLightPost: async (appliance: string, button: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appliance' is not null or undefined
            assertParamExists('_1appliancesApplianceLightPost', 'appliance', appliance)
            // verify required parameter 'button' is not null or undefined
            assertParamExists('_1appliancesApplianceLightPost', 'button', button)
            const localVarPath = `/1/appliances/{appliance}/light`
                .replace(`{${"appliance"}}`, encodeURIComponent(String(appliance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["sendir"], configuration)


            if (button !== undefined) { 
                localVarFormParams.set('button', button as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update appliance.
         * @param {string} appliance Appliance ID.
         * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_ac_1\\\&quot; 
         * @param {string} nickname Appliance name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesAppliancePost: async (appliance: string, image: string, nickname: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appliance' is not null or undefined
            assertParamExists('_1appliancesAppliancePost', 'appliance', appliance)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('_1appliancesAppliancePost', 'image', image)
            // verify required parameter 'nickname' is not null or undefined
            assertParamExists('_1appliancesAppliancePost', 'nickname', nickname)
            const localVarPath = `/1/appliances/{appliance}`
                .replace(`{${"appliance"}}`, encodeURIComponent(String(appliance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic"], configuration)


            if (image !== undefined) { 
                localVarFormParams.set('image', image as any);
            }
    
            if (nickname !== undefined) { 
                localVarFormParams.set('nickname', nickname as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reorder signals under this appliance.
         * @param {string} appliance Appliance ID.
         * @param {string} signals List of all signals\\\&#39; IDs comma separated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesApplianceSignalOrdersPost: async (appliance: string, signals: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appliance' is not null or undefined
            assertParamExists('_1appliancesApplianceSignalOrdersPost', 'appliance', appliance)
            // verify required parameter 'signals' is not null or undefined
            assertParamExists('_1appliancesApplianceSignalOrdersPost', 'signals', signals)
            const localVarPath = `/1/appliances/{appliance}/signal_orders`
                .replace(`{${"appliance"}}`, encodeURIComponent(String(appliance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic"], configuration)


            if (signals !== undefined) { 
                localVarFormParams.set('signals', signals as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch signals registered under this appliance.
         * @param {string} appliance Appliance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesApplianceSignalsGet: async (appliance: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appliance' is not null or undefined
            assertParamExists('_1appliancesApplianceSignalsGet', 'appliance', appliance)
            const localVarPath = `/1/appliances/{appliance}/signals`
                .replace(`{${"appliance"}}`, encodeURIComponent(String(appliance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic.read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a signal under this appliance.
         * @param {string} appliance Appliance ID.
         * @param {string} message JSON serialized object describing infrared signals. Includes \\\&quot;data\\\&quot;, \\\&quot;freq\\\&quot; and \\\&quot;format\\\&quot; keys.
         * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_io\\\&quot; 
         * @param {string} name Signal name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesApplianceSignalsPost: async (appliance: string, message: string, image: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appliance' is not null or undefined
            assertParamExists('_1appliancesApplianceSignalsPost', 'appliance', appliance)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('_1appliancesApplianceSignalsPost', 'message', message)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('_1appliancesApplianceSignalsPost', 'image', image)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('_1appliancesApplianceSignalsPost', 'name', name)
            const localVarPath = `/1/appliances/{appliance}/signals`
                .replace(`{${"appliance"}}`, encodeURIComponent(String(appliance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic"], configuration)


            if (message !== undefined) { 
                localVarFormParams.set('message', message as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.set('image', image as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send tv infrared signal.
         * @param {string} appliance Appliance ID.
         * @param {string} button Button name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesApplianceTvPost: async (appliance: string, button: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'appliance' is not null or undefined
            assertParamExists('_1appliancesApplianceTvPost', 'appliance', appliance)
            // verify required parameter 'button' is not null or undefined
            assertParamExists('_1appliancesApplianceTvPost', 'button', button)
            const localVarPath = `/1/appliances/{appliance}/tv`
                .replace(`{${"appliance"}}`, encodeURIComponent(String(appliance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["sendir"], configuration)


            if (button !== undefined) { 
                localVarFormParams.set('button', button as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the list of appliances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1/appliances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic.read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new appliance.
         * @param {string} nickname Appliance name
         * @param {string} device Device ID
         * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_ac_1\\\&quot; 
         * @param {string} [model] ApplianceModel ID if the appliance we\\\&#39;re trying to create is included in IRDB.
         * @param {string} [modelType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesPost: async (nickname: string, device: string, image: string, model?: string, modelType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nickname' is not null or undefined
            assertParamExists('_1appliancesPost', 'nickname', nickname)
            // verify required parameter 'device' is not null or undefined
            assertParamExists('_1appliancesPost', 'device', device)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('_1appliancesPost', 'image', image)
            const localVarPath = `/1/appliances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic"], configuration)


            if (nickname !== undefined) { 
                localVarFormParams.set('nickname', nickname as any);
            }
    
            if (model !== undefined) { 
                localVarFormParams.set('model', model as any);
            }
    
            if (modelType !== undefined) { 
                localVarFormParams.set('model_type', modelType as any);
            }
    
            if (device !== undefined) { 
                localVarFormParams.set('device', device as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.set('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find the air conditioner best matching the provided infrared signal.
         * @param {string} message JSON serialized object describing infrared signals. Includes \\\&quot;data\\\&quot;, \\\&quot;freq\\\&quot; and \\\&quot;format\\\&quot; keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1detectappliancePost: async (message: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'message' is not null or undefined
            assertParamExists('_1detectappliancePost', 'message', message)
            const localVarPath = `/1/detectappliance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["detectappliance"], configuration)


            if (message !== undefined) { 
                localVarFormParams.set('message', message as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Remo.
         * @param {string} device Device ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1devicesDeviceDeletePost: async (device: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'device' is not null or undefined
            assertParamExists('_1devicesDeviceDeletePost', 'device', device)
            const localVarPath = `/1/devices/{device}/delete`
                .replace(`{${"device"}}`, encodeURIComponent(String(device)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update humidity offset.
         * @param {string} device Device ID.
         * @param {number} offset Humidity offset value added to the measured humidity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1devicesDeviceHumidityOffsetPost: async (device: string, offset: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'device' is not null or undefined
            assertParamExists('_1devicesDeviceHumidityOffsetPost', 'device', device)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('_1devicesDeviceHumidityOffsetPost', 'offset', offset)
            const localVarPath = `/1/devices/{device}/humidity_offset`
                .replace(`{${"device"}}`, encodeURIComponent(String(device)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic"], configuration)


            if (offset !== undefined) { 
                localVarFormParams.set('offset', offset as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Remo
         * @param {string} device Device ID.
         * @param {string} name Signal name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1devicesDevicePost: async (device: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'device' is not null or undefined
            assertParamExists('_1devicesDevicePost', 'device', device)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('_1devicesDevicePost', 'name', name)
            const localVarPath = `/1/devices/{device}`
                .replace(`{${"device"}}`, encodeURIComponent(String(device)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic"], configuration)


            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update temperature offset.
         * @param {string} device Device ID.
         * @param {number} offset Temperature offset value added to the measured temperature.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1devicesDeviceTemperatureOffsetPost: async (device: string, offset: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'device' is not null or undefined
            assertParamExists('_1devicesDeviceTemperatureOffsetPost', 'device', device)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('_1devicesDeviceTemperatureOffsetPost', 'offset', offset)
            const localVarPath = `/1/devices/{device}/temperature_offset`
                .replace(`{${"device"}}`, encodeURIComponent(String(device)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic"], configuration)


            if (offset !== undefined) { 
                localVarFormParams.set('offset', offset as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the list of Remo devices the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1devicesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic.read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an infrared signal.
         * @param {string} signal Signal ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1signalsSignalDeletePost: async (signal: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signal' is not null or undefined
            assertParamExists('_1signalsSignalDeletePost', 'signal', signal)
            const localVarPath = `/1/signals/{signal}/delete`
                .replace(`{${"signal"}}`, encodeURIComponent(String(signal)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update infrared signal.
         * @param {string} signal Signal ID.
         * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_io\\\&quot; 
         * @param {string} name Signal name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1signalsSignalPost: async (signal: string, image: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signal' is not null or undefined
            assertParamExists('_1signalsSignalPost', 'signal', signal)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('_1signalsSignalPost', 'image', image)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('_1signalsSignalPost', 'name', name)
            const localVarPath = `/1/signals/{signal}`
                .replace(`{${"signal"}}`, encodeURIComponent(String(signal)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic"], configuration)


            if (image !== undefined) { 
                localVarFormParams.set('image', image as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send infrared signal.
         * @param {string} signal Signal ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1signalsSignalSendPost: async (signal: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signal' is not null or undefined
            assertParamExists('_1signalsSignalSendPost', 'signal', signal)
            const localVarPath = `/1/signals/{signal}/send`
                .replace(`{${"signal"}}`, encodeURIComponent(String(signal)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["sendir"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the authenticated user\'s information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1usersMeGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic.read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update authenticated user\'s information.
         * @param {string} nickname User\\\&#39;s nickname. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1usersMePost: async (nickname: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nickname' is not null or undefined
            assertParamExists('_1usersMePost', 'nickname', nickname)
            const localVarPath = `/1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", ["basic"], configuration)


            if (nickname !== undefined) { 
                localVarFormParams.set('nickname', nickname as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Reorder appliances.
         * @param {string} appliances List of all appliances\\\&#39; IDs comma separated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1applianceOrdersPost(appliances: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1applianceOrdersPost(appliances, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update air conditioner settings.
         * @param {string} appliance Appliance ID.
         * @param {string} [temperature] Temperature
         * @param {string} [operationMode] AC operation mode
         * @param {string} [airVolume] AC air volume
         * @param {string} [airDirection] AC air direction
         * @param {string} [button] Button
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1appliancesApplianceAirconSettingsPost(appliance: string, temperature?: string, operationMode?: string, airVolume?: string, airDirection?: string, button?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1appliancesApplianceAirconSettingsPost(appliance, temperature, operationMode, airVolume, airDirection, button, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete appliance.
         * @param {string} appliance Appliance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1appliancesApplianceDeletePost(appliance: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1appliancesApplianceDeletePost(appliance, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send light infrared signal.
         * @param {string} appliance Appliance ID.
         * @param {string} button Button name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1appliancesApplianceLightPost(appliance: string, button: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1appliancesApplianceLightPost(appliance, button, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update appliance.
         * @param {string} appliance Appliance ID.
         * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_ac_1\\\&quot; 
         * @param {string} nickname Appliance name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1appliancesAppliancePost(appliance: string, image: string, nickname: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appliance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1appliancesAppliancePost(appliance, image, nickname, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reorder signals under this appliance.
         * @param {string} appliance Appliance ID.
         * @param {string} signals List of all signals\\\&#39; IDs comma separated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1appliancesApplianceSignalOrdersPost(appliance: string, signals: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1appliancesApplianceSignalOrdersPost(appliance, signals, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch signals registered under this appliance.
         * @param {string} appliance Appliance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1appliancesApplianceSignalsGet(appliance: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Signal>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1appliancesApplianceSignalsGet(appliance, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a signal under this appliance.
         * @param {string} appliance Appliance ID.
         * @param {string} message JSON serialized object describing infrared signals. Includes \\\&quot;data\\\&quot;, \\\&quot;freq\\\&quot; and \\\&quot;format\\\&quot; keys.
         * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_io\\\&quot; 
         * @param {string} name Signal name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1appliancesApplianceSignalsPost(appliance: string, message: string, image: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Signal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1appliancesApplianceSignalsPost(appliance, message, image, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send tv infrared signal.
         * @param {string} appliance Appliance ID.
         * @param {string} button Button name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1appliancesApplianceTvPost(appliance: string, button: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1appliancesApplianceTvPost(appliance, button, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch the list of appliances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1appliancesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Appliance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1appliancesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new appliance.
         * @param {string} nickname Appliance name
         * @param {string} device Device ID
         * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_ac_1\\\&quot; 
         * @param {string} [model] ApplianceModel ID if the appliance we\\\&#39;re trying to create is included in IRDB.
         * @param {string} [modelType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1appliancesPost(nickname: string, device: string, image: string, model?: string, modelType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appliance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1appliancesPost(nickname, device, image, model, modelType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find the air conditioner best matching the provided infrared signal.
         * @param {string} message JSON serialized object describing infrared signals. Includes \\\&quot;data\\\&quot;, \\\&quot;freq\\\&quot; and \\\&quot;format\\\&quot; keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1detectappliancePost(message: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplianceModelAndParam>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1detectappliancePost(message, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Remo.
         * @param {string} device Device ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1devicesDeviceDeletePost(device: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1devicesDeviceDeletePost(device, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update humidity offset.
         * @param {string} device Device ID.
         * @param {number} offset Humidity offset value added to the measured humidity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1devicesDeviceHumidityOffsetPost(device: string, offset: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1devicesDeviceHumidityOffsetPost(device, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Remo
         * @param {string} device Device ID.
         * @param {string} name Signal name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1devicesDevicePost(device: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1devicesDevicePost(device, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update temperature offset.
         * @param {string} device Device ID.
         * @param {number} offset Temperature offset value added to the measured temperature.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1devicesDeviceTemperatureOffsetPost(device: string, offset: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1devicesDeviceTemperatureOffsetPost(device, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch the list of Remo devices the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1devicesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1devicesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an infrared signal.
         * @param {string} signal Signal ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1signalsSignalDeletePost(signal: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1signalsSignalDeletePost(signal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update infrared signal.
         * @param {string} signal Signal ID.
         * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_io\\\&quot; 
         * @param {string} name Signal name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1signalsSignalPost(signal: string, image: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1signalsSignalPost(signal, image, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send infrared signal.
         * @param {string} signal Signal ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1signalsSignalSendPost(signal: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1signalsSignalSendPost(signal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch the authenticated user\'s information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1usersMeGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1usersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update authenticated user\'s information.
         * @param {string} nickname User\\\&#39;s nickname. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _1usersMePost(nickname: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._1usersMePost(nickname, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Reorder appliances.
         * @param {string} appliances List of all appliances\\\&#39; IDs comma separated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1applianceOrdersPost(appliances: string, options?: any): AxiosPromise<void> {
            return localVarFp._1applianceOrdersPost(appliances, options).then((request) => request(axios, basePath));
        },
        /**
         * Update air conditioner settings.
         * @param {string} appliance Appliance ID.
         * @param {string} [temperature] Temperature
         * @param {string} [operationMode] AC operation mode
         * @param {string} [airVolume] AC air volume
         * @param {string} [airDirection] AC air direction
         * @param {string} [button] Button
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesApplianceAirconSettingsPost(appliance: string, temperature?: string, operationMode?: string, airVolume?: string, airDirection?: string, button?: string, options?: any): AxiosPromise<void> {
            return localVarFp._1appliancesApplianceAirconSettingsPost(appliance, temperature, operationMode, airVolume, airDirection, button, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete appliance.
         * @param {string} appliance Appliance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesApplianceDeletePost(appliance: string, options?: any): AxiosPromise<void> {
            return localVarFp._1appliancesApplianceDeletePost(appliance, options).then((request) => request(axios, basePath));
        },
        /**
         * Send light infrared signal.
         * @param {string} appliance Appliance ID.
         * @param {string} button Button name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesApplianceLightPost(appliance: string, button: string, options?: any): AxiosPromise<void> {
            return localVarFp._1appliancesApplianceLightPost(appliance, button, options).then((request) => request(axios, basePath));
        },
        /**
         * Update appliance.
         * @param {string} appliance Appliance ID.
         * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_ac_1\\\&quot; 
         * @param {string} nickname Appliance name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesAppliancePost(appliance: string, image: string, nickname: string, options?: any): AxiosPromise<Appliance> {
            return localVarFp._1appliancesAppliancePost(appliance, image, nickname, options).then((request) => request(axios, basePath));
        },
        /**
         * Reorder signals under this appliance.
         * @param {string} appliance Appliance ID.
         * @param {string} signals List of all signals\\\&#39; IDs comma separated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesApplianceSignalOrdersPost(appliance: string, signals: string, options?: any): AxiosPromise<void> {
            return localVarFp._1appliancesApplianceSignalOrdersPost(appliance, signals, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch signals registered under this appliance.
         * @param {string} appliance Appliance ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesApplianceSignalsGet(appliance: string, options?: any): AxiosPromise<Array<Signal>> {
            return localVarFp._1appliancesApplianceSignalsGet(appliance, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a signal under this appliance.
         * @param {string} appliance Appliance ID.
         * @param {string} message JSON serialized object describing infrared signals. Includes \\\&quot;data\\\&quot;, \\\&quot;freq\\\&quot; and \\\&quot;format\\\&quot; keys.
         * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_io\\\&quot; 
         * @param {string} name Signal name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesApplianceSignalsPost(appliance: string, message: string, image: string, name: string, options?: any): AxiosPromise<Signal> {
            return localVarFp._1appliancesApplianceSignalsPost(appliance, message, image, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Send tv infrared signal.
         * @param {string} appliance Appliance ID.
         * @param {string} button Button name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesApplianceTvPost(appliance: string, button: string, options?: any): AxiosPromise<void> {
            return localVarFp._1appliancesApplianceTvPost(appliance, button, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the list of appliances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesGet(options?: any): AxiosPromise<Array<Appliance>> {
            return localVarFp._1appliancesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new appliance.
         * @param {string} nickname Appliance name
         * @param {string} device Device ID
         * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_ac_1\\\&quot; 
         * @param {string} [model] ApplianceModel ID if the appliance we\\\&#39;re trying to create is included in IRDB.
         * @param {string} [modelType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1appliancesPost(nickname: string, device: string, image: string, model?: string, modelType?: string, options?: any): AxiosPromise<Appliance> {
            return localVarFp._1appliancesPost(nickname, device, image, model, modelType, options).then((request) => request(axios, basePath));
        },
        /**
         * Find the air conditioner best matching the provided infrared signal.
         * @param {string} message JSON serialized object describing infrared signals. Includes \\\&quot;data\\\&quot;, \\\&quot;freq\\\&quot; and \\\&quot;format\\\&quot; keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1detectappliancePost(message: string, options?: any): AxiosPromise<Array<ApplianceModelAndParam>> {
            return localVarFp._1detectappliancePost(message, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Remo.
         * @param {string} device Device ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1devicesDeviceDeletePost(device: string, options?: any): AxiosPromise<void> {
            return localVarFp._1devicesDeviceDeletePost(device, options).then((request) => request(axios, basePath));
        },
        /**
         * Update humidity offset.
         * @param {string} device Device ID.
         * @param {number} offset Humidity offset value added to the measured humidity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1devicesDeviceHumidityOffsetPost(device: string, offset: number, options?: any): AxiosPromise<void> {
            return localVarFp._1devicesDeviceHumidityOffsetPost(device, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Remo
         * @param {string} device Device ID.
         * @param {string} name Signal name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1devicesDevicePost(device: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp._1devicesDevicePost(device, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Update temperature offset.
         * @param {string} device Device ID.
         * @param {number} offset Temperature offset value added to the measured temperature.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1devicesDeviceTemperatureOffsetPost(device: string, offset: number, options?: any): AxiosPromise<void> {
            return localVarFp._1devicesDeviceTemperatureOffsetPost(device, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the list of Remo devices the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1devicesGet(options?: any): AxiosPromise<Array<Device>> {
            return localVarFp._1devicesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an infrared signal.
         * @param {string} signal Signal ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1signalsSignalDeletePost(signal: string, options?: any): AxiosPromise<void> {
            return localVarFp._1signalsSignalDeletePost(signal, options).then((request) => request(axios, basePath));
        },
        /**
         * Update infrared signal.
         * @param {string} signal Signal ID.
         * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_io\\\&quot; 
         * @param {string} name Signal name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1signalsSignalPost(signal: string, image: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp._1signalsSignalPost(signal, image, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Send infrared signal.
         * @param {string} signal Signal ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1signalsSignalSendPost(signal: string, options?: any): AxiosPromise<void> {
            return localVarFp._1signalsSignalSendPost(signal, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the authenticated user\'s information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1usersMeGet(options?: any): AxiosPromise<User> {
            return localVarFp._1usersMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update authenticated user\'s information.
         * @param {string} nickname User\\\&#39;s nickname. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _1usersMePost(nickname: string, options?: any): AxiosPromise<User> {
            return localVarFp._1usersMePost(nickname, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Reorder appliances.
     * @param {string} appliances List of all appliances\\\&#39; IDs comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1applianceOrdersPost(appliances: string, options?: any) {
        return DefaultApiFp(this.configuration)._1applianceOrdersPost(appliances, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update air conditioner settings.
     * @param {string} appliance Appliance ID.
     * @param {string} [temperature] Temperature
     * @param {string} [operationMode] AC operation mode
     * @param {string} [airVolume] AC air volume
     * @param {string} [airDirection] AC air direction
     * @param {string} [button] Button
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1appliancesApplianceAirconSettingsPost(appliance: string, temperature?: string, operationMode?: string, airVolume?: string, airDirection?: string, button?: string, options?: any) {
        return DefaultApiFp(this.configuration)._1appliancesApplianceAirconSettingsPost(appliance, temperature, operationMode, airVolume, airDirection, button, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete appliance.
     * @param {string} appliance Appliance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1appliancesApplianceDeletePost(appliance: string, options?: any) {
        return DefaultApiFp(this.configuration)._1appliancesApplianceDeletePost(appliance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send light infrared signal.
     * @param {string} appliance Appliance ID.
     * @param {string} button Button name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1appliancesApplianceLightPost(appliance: string, button: string, options?: any) {
        return DefaultApiFp(this.configuration)._1appliancesApplianceLightPost(appliance, button, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update appliance.
     * @param {string} appliance Appliance ID.
     * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_ac_1\\\&quot; 
     * @param {string} nickname Appliance name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1appliancesAppliancePost(appliance: string, image: string, nickname: string, options?: any) {
        return DefaultApiFp(this.configuration)._1appliancesAppliancePost(appliance, image, nickname, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reorder signals under this appliance.
     * @param {string} appliance Appliance ID.
     * @param {string} signals List of all signals\\\&#39; IDs comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1appliancesApplianceSignalOrdersPost(appliance: string, signals: string, options?: any) {
        return DefaultApiFp(this.configuration)._1appliancesApplianceSignalOrdersPost(appliance, signals, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch signals registered under this appliance.
     * @param {string} appliance Appliance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1appliancesApplianceSignalsGet(appliance: string, options?: any) {
        return DefaultApiFp(this.configuration)._1appliancesApplianceSignalsGet(appliance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a signal under this appliance.
     * @param {string} appliance Appliance ID.
     * @param {string} message JSON serialized object describing infrared signals. Includes \\\&quot;data\\\&quot;, \\\&quot;freq\\\&quot; and \\\&quot;format\\\&quot; keys.
     * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_io\\\&quot; 
     * @param {string} name Signal name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1appliancesApplianceSignalsPost(appliance: string, message: string, image: string, name: string, options?: any) {
        return DefaultApiFp(this.configuration)._1appliancesApplianceSignalsPost(appliance, message, image, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send tv infrared signal.
     * @param {string} appliance Appliance ID.
     * @param {string} button Button name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1appliancesApplianceTvPost(appliance: string, button: string, options?: any) {
        return DefaultApiFp(this.configuration)._1appliancesApplianceTvPost(appliance, button, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the list of appliances.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1appliancesGet(options?: any) {
        return DefaultApiFp(this.configuration)._1appliancesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new appliance.
     * @param {string} nickname Appliance name
     * @param {string} device Device ID
     * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_ac_1\\\&quot; 
     * @param {string} [model] ApplianceModel ID if the appliance we\\\&#39;re trying to create is included in IRDB.
     * @param {string} [modelType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1appliancesPost(nickname: string, device: string, image: string, model?: string, modelType?: string, options?: any) {
        return DefaultApiFp(this.configuration)._1appliancesPost(nickname, device, image, model, modelType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find the air conditioner best matching the provided infrared signal.
     * @param {string} message JSON serialized object describing infrared signals. Includes \\\&quot;data\\\&quot;, \\\&quot;freq\\\&quot; and \\\&quot;format\\\&quot; keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1detectappliancePost(message: string, options?: any) {
        return DefaultApiFp(this.configuration)._1detectappliancePost(message, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Remo.
     * @param {string} device Device ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1devicesDeviceDeletePost(device: string, options?: any) {
        return DefaultApiFp(this.configuration)._1devicesDeviceDeletePost(device, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update humidity offset.
     * @param {string} device Device ID.
     * @param {number} offset Humidity offset value added to the measured humidity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1devicesDeviceHumidityOffsetPost(device: string, offset: number, options?: any) {
        return DefaultApiFp(this.configuration)._1devicesDeviceHumidityOffsetPost(device, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Remo
     * @param {string} device Device ID.
     * @param {string} name Signal name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1devicesDevicePost(device: string, name: string, options?: any) {
        return DefaultApiFp(this.configuration)._1devicesDevicePost(device, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update temperature offset.
     * @param {string} device Device ID.
     * @param {number} offset Temperature offset value added to the measured temperature.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1devicesDeviceTemperatureOffsetPost(device: string, offset: number, options?: any) {
        return DefaultApiFp(this.configuration)._1devicesDeviceTemperatureOffsetPost(device, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the list of Remo devices the user has access to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1devicesGet(options?: any) {
        return DefaultApiFp(this.configuration)._1devicesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an infrared signal.
     * @param {string} signal Signal ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1signalsSignalDeletePost(signal: string, options?: any) {
        return DefaultApiFp(this.configuration)._1signalsSignalDeletePost(signal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update infrared signal.
     * @param {string} signal Signal ID.
     * @param {string} image Basename of the image file included in the app. Ex: \\\&quot;ico_io\\\&quot; 
     * @param {string} name Signal name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1signalsSignalPost(signal: string, image: string, name: string, options?: any) {
        return DefaultApiFp(this.configuration)._1signalsSignalPost(signal, image, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send infrared signal.
     * @param {string} signal Signal ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1signalsSignalSendPost(signal: string, options?: any) {
        return DefaultApiFp(this.configuration)._1signalsSignalSendPost(signal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the authenticated user\'s information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1usersMeGet(options?: any) {
        return DefaultApiFp(this.configuration)._1usersMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update authenticated user\'s information.
     * @param {string} nickname User\\\&#39;s nickname. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public _1usersMePost(nickname: string, options?: any) {
        return DefaultApiFp(this.configuration)._1usersMePost(nickname, options).then((request) => request(this.axios, this.basePath));
    }
}


